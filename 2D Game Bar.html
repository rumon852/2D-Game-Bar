<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Typing Attack</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden; /* Prevent scrollbars */
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let soundsEnabled = true;
        let running = true;

        // Responsive resize
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Keep pause button inside canvas on resize
            pauseButton.x = canvas.width - 60;
            pauseButton.y = 60;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Game states
        const STATES = { MENU: 'menu', PLAYING: 'playing', PAUSED: 'paused', GAMEOVER: 'gameover' };
        let state = STATES.MENU;

        // Difficulty settings
        const DIFFICULTIES = {
            EASY: { speed: 0.5, wordLength: [2, 4], spawnRate: 3000 },
            NORMAL: { speed: 2, wordLength: [5, 8], spawnRate: 1500 },
            EXPERT: { speed: 3, wordLength: [8, 12], spawnRate: 1000 }
        };
        let difficulty = 'EASY';

        // Word list
        const allWords = 'a,abandon,ability,able,about,above,abroad,absence,absolute,absorb,abuse,accept,access,accident,accompany,accomplish,account,accurate,accuse,achieve,acid,acknowledge,acquire,across,act,action,active,activity,actor,actress,actual,add,address,adjust,admire,adopt,adult,advance,advantage,advice,affair,affect,afford,afraid,after,afternoon,again,against,age,agency,agent,agree,agreement,ago,air,airport,alarm,album,alive,allow,almost,alone,along,already,also,although,always,amazing,among,amount,analysis,ancient,and,anger,animal,answer,anxiety,any,anyone,anything,anyway,apart,apartment,apple,apply,appoint,approach,approval,approve,area,argue,army,around,arrange,arrest,arrive,art,artist,as,ask,aspect,assault,assist,assume,at,athlete,attack,attempt,attend,attention,attitude,attract,audience,author,available,avoid,award,aware,baby,back,bad,bag,balance,ball,bank,bar,base,baseball,basic,basket,bath,battle,be,beach,bear,beat,beautiful,because,become,bed,beer,before,begin,behavior,behind,being,belief,believe,bell,belong,below,best,better,between,beyond,big,bike,bill,bird,birth,bit,black,blade,blame,blanket,blind,block,blood,blue,board,boat,body,bone,book,boom,boss,both,bottle,bottom,bowl,box,boy,brain,branch,brand,bread,break,breakfast,breath,bridge,bright,bring,broad,broken,brother,brown,brush,build,building,burn,business,but,buy,by'.split(',');

        function getWordsByLength(min, max) {
            return allWords.filter(w => w.length >= min && w.length <= max);
        }

        // Game variables
        let player = { x: canvas.width / 2, y: canvas.height - 50, health: 5 };
        let enemies = [];
        let particles = [];
        let lasers = [];
        let stars = [];
        let score = 0;
        let typed = '';
        let targetedEnemy = null;
        let lastSpawn = 0;
        let startTime = null;
        let wordsDestroyed = 0;
        let totalCorrectChars = 0;
        let errorCount = 0;

        // Stars
        function generateStars(count = 100) {
            stars = [];
            for (let i = 0; i < count; i++) {
                stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2 + 1 });
            }
        }
        generateStars(100);

        // Sounds
        async function ensureAudio() {
            // resume audio context if suspended (some browsers block autoplay)
            if (audioCtx && audioCtx.state === 'suspended') {
                try { await audioCtx.resume(); } catch (e) { /* ignore */ }
            }
        }
        function playSound(freq, duration, type = 'sine') {
            if (!soundsEnabled) return;
            try {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.value = freq;
                osc.type = type;
                const now = audioCtx.currentTime;
                gain.gain.setValueAtTime(0.0001, now);
                gain.gain.exponentialRampToValueAtTime(0.5, now + 0.01);
                osc.start(now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                osc.stop(now + duration + 0.02);
            } catch (err) {
                // audio not available â€” ignore silently
            }
        }
        function playShoot() { playSound(800, 0.08, 'square'); }
        function playExplosion() { playSound(100, 0.25, 'sawtooth'); }
        function playWrong() { playSound(200, 0.12, 'triangle'); }

        function getRandomWord(minLen, maxLen) {
            const filtered = getWordsByLength(minLen, maxLen);
            return filtered[Math.floor(Math.random() * filtered.length)] || 'word';
        }

        // Enemy class
        class Enemy {
            constructor(x, y, word, speed) {
                this.x = x;
                this.y = y;
                this.word = word.toLowerCase();
                this.speed = speed;
                this.size = 30;
            }
            update() {
                this.y += this.speed;
                if (this.y > canvas.height - 50) {
                    player.health--;
                    enemies = enemies.filter(e => e !== this);
                    if (this === targetedEnemy) {
                        typed = '';
                        targetedEnemy = null;
                    }
                    if (player.health <= 0) state = STATES.GAMEOVER;
                }
            }
            draw() {
                ctx.shadowColor = this === targetedEnemy ? '#00ff00' : '#ff00ff';
                ctx.shadowBlur = this === targetedEnemy ? 20 : 15;

                // Draw cartoon character sprite (simple alien)
                ctx.fillStyle = this === targetedEnemy ? '#00ff00' : '#ff00ff';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.size, this.size * 0.8, 0, 0, Math.PI * 2); // Oval head
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x - this.size / 3, this.y - this.size / 4, this.size / 6, 0, Math.PI * 2);
                ctx.arc(this.x + this.size / 3, this.y - this.size / 4, this.size / 6, 0, Math.PI * 2);
                ctx.fill();

                // Pupils
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(this.x - this.size / 3, this.y - this.size / 4, this.size / 12, 0, Math.PI * 2);
                ctx.arc(this.x + this.size / 3, this.y - this.size / 4, this.size / 12, 0, Math.PI * 2);
                ctx.fill();

                // Mouth
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y + this.size / 4, this.size / 4, 0, Math.PI);
                ctx.stroke();

                ctx.shadowBlur = 0;

                // Draw text overlay with contrast
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                const textY = this.y - this.size - 8;
                const textWidth = ctx.measureText(this.word).width;
                const rectX = this.x - textWidth / 2 - 5;
                const rectY = textY - 14;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(rectX, rectY, textWidth + 10, 20);

                if (this === targetedEnemy && typed.length > 0) {
                    // Dim full word
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.fillText(this.word, this.x, textY);

                    // Bright typed prefix overlay
                    const prefix = typed;
                    // To position prefix accurately, measure prefix width and offset relative to full word center
                    const prefixWidth = ctx.measureText(prefix).width;
                    // Calculate starting X for full word
                    const startX = this.x - textWidth / 2;
                    // Draw prefix in green
                    ctx.fillStyle = '#00ff00';
                    // Draw the prefix centered at startX + prefixWidth/2
                    ctx.fillText(prefix, startX + prefixWidth / 2, textY);
                } else {
                    // Normal word
                    ctx.fillStyle = '#fff';
                    ctx.fillText(this.word, this.x, textY);
                }
            }
        }

        class Particle {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.vx = Math.random() * 4 - 2;
                this.vy = Math.random() * 4 - 2;
                this.life = 20;
                this.color = '#ff00ff';
            }
            update() { this.x += this.vx; this.y += this.vy; this.life--; }
            draw() { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, 2, 2); }
        }

        class Laser {
            constructor(sx, sy, ex, ey) {
                this.startX = sx; this.startY = sy;
                this.endX = ex; this.endY = ey;
                this.life = 10;
            }
            update() { this.life--; }
            draw() {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.startX, this.startY);
                ctx.lineTo(this.endX, this.endY);
                ctx.stroke();
            }
        }

        function drawStars() {
            ctx.fillStyle = '#fff';
            stars.forEach(s => ctx.fillRect(s.x, s.y, s.size, s.size));
        }

        function drawPlayer() {
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.moveTo(player.x, player.y - 30);
            ctx.lineTo(player.x - 25, player.y + 20);
            ctx.lineTo(player.x + 25, player.y + 20);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function spawnEnemy() {
            const config = DIFFICULTIES[difficulty];
            const x = Math.random() * (canvas.width - 100) + 50;
            const word = getRandomWord(...config.wordLength);
            enemies.push(new Enemy(x, -30, word, config.speed));
        }

        // Typing
        window.addEventListener('keydown', async (e) => {
            // Allow audio resume on any user interaction
            await ensureAudio();

            if (e.key === 'Escape') {
                // Toggle pause <-> playing
                if (state === STATES.PLAYING) { state = STATES.PAUSED; }
                else if (state === STATES.PAUSED) { state = STATES.PLAYING; }
                // If we're in menu or gameover, ignore escape
                return;
            }

            if (state !== STATES.PLAYING) return;

            const key = e.key.toLowerCase();

            if (key.length === 1 && key.match(/[a-z]/)) {
                if (!startTime) startTime = Date.now();
                typed += key;

                // Create laser effect for each keystroke when targeting an enemy
                if (targetedEnemy) {
                    playShoot();
                    lasers.push(new Laser(player.x, player.y - 30, targetedEnemy.x, targetedEnemy.y));
                }

                checkMatch();
            } else if (e.key === 'Backspace') {
                typed = typed.slice(0, -1);
                // If typed becomes empty, clear targeting
                if (typed === '') targetedEnemy = null;
                else checkMatch();
            }
        });

        function checkMatch() {
            // If typed is empty, nothing to match
            if (!typed) {
                targetedEnemy = null;
                return;
            }

            // If we have a currently targeted enemy, check it first
            if (targetedEnemy) {
                if (!targetedEnemy.word.startsWith(typed)) {
                    // Wrong input for this target
                    errorCount++;
                    typed = '';
                    targetedEnemy = null;
                    playWrong();
                    return;
                } else if (typed === targetedEnemy.word) {
                    // Correct full word
                    handleEnemyDestroyed(targetedEnemy);
                    return;
                } else {
                    // Partial match â€” keep targeting
                    return;
                }
            }

            // No targeted enemy â€” try to find one matching typed prefix
            const targets = enemies.filter(e => e.word.startsWith(typed));
            if (targets.length > 0) {
                // Choose the lowest enemy (closest to player) to prioritize immediate threats
                targets.sort((a, b) => b.y - a.y);
                targetedEnemy = targets[0];
            } else {
                // No match at all
                errorCount++;
                typed = '';
                targetedEnemy = null;
                playWrong();
            }
        }

        function handleEnemyDestroyed(enemy) {
            // Create explosion + particles + sound
            if (soundsEnabled) playExplosion();
            for (let i = 0; i < 10; i++) particles.push(new Particle(enemy.x, enemy.y));
            enemies = enemies.filter(e => e !== enemy);
            totalCorrectChars += enemy.word.length;
            wordsDestroyed++;
            // Award more points based on word length and difficulty
            const wordBonus = enemy.word.length * 5;
            const difficultyMultiplier = difficulty === 'EASY' ? 1 : (difficulty === 'NORMAL' ? 2 : 3);
            score += (10 + wordBonus) * difficultyMultiplier;
            typed = '';
            targetedEnemy = null;
        }

        // Pause button object
        let pauseButton = {
            x: canvas.width - 60,
            y: 60,
            radius: 20,
            draw: function() {
                // Draw button circle
                ctx.fillStyle = '#ff9900';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Draw pause icon
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x - 7, this.y - 10, 5, 20);
                ctx.fillRect(this.x + 2, this.y - 10, 5, 20);

                // Add outline
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
            },
            isClicked: function(x, y) {
                const distance = Math.sqrt(Math.pow(x - this.x, 2) + Math.pow(y - this.y, 2));
                return distance <= this.radius;
            }
        };

        function drawHUD() {
            // Draw score with highlight
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            ctx.fillText('Score: ' + score, 20, 30);
            ctx.shadowBlur = 0;

            // Draw health
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('Health: ' + player.health, canvas.width - 20, 30);

            // Draw typed text
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fff';
            ctx.fillText('Typed: ' + (typed || '_'), canvas.width / 2, canvas.height - 20);

            // Draw pause button
            pauseButton.x = canvas.width - 60; // Update position in case of window resize
            pauseButton.y = 60;
            pauseButton.draw();
        }

        // BUTTON SYSTEM
        function drawButton(text, x, y, mode, isHovered) {
            const w = 300, h = 40;
            const bx = x - w / 2, by = y - h / 2;
            ctx.fillStyle = isHovered ? "#ffaa33" : "#ff9900";
            ctx.fillRect(bx, by, w, h);
            ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.strokeRect(bx, by, w, h);
            ctx.fillStyle = "#000"; ctx.font = "20px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(text, x, y);
            return { x: bx, y: by, width: w, height: h, mode };
        }

        let menuButtons = [];
        let pauseButtons = [];
        let gameoverButtons = [];
        let mousePos = null;
        canvas.addEventListener("mousemove", e => {
            const r = canvas.getBoundingClientRect();
            mousePos = { x: e.clientX - r.left, y: e.clientY - r.top };
        });

        function drawMenu() {
            drawStars();
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 20;
            ctx.font = '60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('TYPING ATTACK', canvas.width / 2, canvas.height / 2 - 150);
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#fff';
            ctx.font = '30px Arial';
            ctx.fillText('Type to Survive!', canvas.width / 2, canvas.height / 2 - 90);

            menuButtons = [];
            // We'll compute hovered state from mousePos and button rect after drawing
            const easyRect = drawButton("Play Easy Mode", canvas.width / 2, canvas.height / 2 - 20, "EASY", false);
            const normalRect = drawButton("Play Normal Mode", canvas.width / 2, canvas.height / 2 + 40, "NORMAL", false);
            const expertRect = drawButton("Play Expert Mode", canvas.width / 2, canvas.height / 2 + 100, "EXPERT", false);
            const closeRect = drawButton("Close Game", canvas.width / 2, canvas.height / 2 + 160, "CLOSE", false);

            // Re-draw with hover styling if mouse is over
            menuButtons = [easyRect, normalRect, expertRect, closeRect];
            if (mousePos) {
                for (let i = 0; i < menuButtons.length; i++) {
                    const b = menuButtons[i];
                    const hovered = mousePos.x > b.x && mousePos.x < b.x + b.width && mousePos.y > b.y && mousePos.y < b.y + b.height;
                    if (hovered) {
                        // redraw hovered
                        drawButton(i === 0 ? "Play Easy Mode" : i === 1 ? "Play Normal Mode" : i === 2 ? "Play Expert Mode" : "Close Game",
                                   canvas.width / 2, canvas.height / 2 - 20 + i * 60, b.mode, true);
                    }
                }
            }

            ctx.font = '16px Arial'; ctx.fillStyle = '#fff';
            ctx.fillText("Created by Host Rumon", canvas.width / 2, canvas.height - 30);
        }

        function handleClick(e) {
            const r = canvas.getBoundingClientRect();
            const x = (e.clientX || (e.touches && e.touches[0].clientX)) - r.left;
            const y = (e.clientY || (e.touches && e.touches[0].clientY)) - r.top;

            // Check if pause button was clicked during gameplay
            if (state === STATES.PLAYING && pauseButton.isClicked(x, y)) {
                state = STATES.PAUSED;
                return;
            }

            if (state === STATES.MENU) {
                for (let btn of menuButtons) {
                    if (x > btn.x && x < btn.x + btn.width && y > btn.y && y < btn.y + btn.height) {
                        if (btn.mode === "CLOSE") {
                            running = false;
                            canvas.style.display = 'none';
                        } else {
                            difficulty = btn.mode;
                            startGame();
                        }
                    }
                }
            } else if (state === STATES.PAUSED) {
                for (let btn of pauseButtons) {
                    if (x > btn.x && x < btn.x + btn.width && y > btn.y && y < btn.y + btn.height) {
                        if (btn.mode === "RESUME") {
                            state = STATES.PLAYING;
                        } else if (btn.mode === "MENU") {
                            state = STATES.MENU;
                        } else if (btn.mode === "CLOSE") {
                            running = false;
                            canvas.style.display = 'none';
                        }
                    }
                }
            } else if (state === STATES.GAMEOVER) {
                for (let btn of gameoverButtons) {
                    if (x > btn.x && x < btn.x + btn.width && y > btn.y && y < btn.y + btn.height) {
                        if (btn.mode === "MENU") {
                            state = STATES.MENU;
                        } else if (btn.mode === "CLOSE") {
                            running = false;
                            canvas.style.display = 'none';
                        }
                    }
                }
            }
        }
        canvas.addEventListener('click', handleClick);

        function startGame() {
            state = STATES.PLAYING;
            player.health = 5; score = 0;
            enemies = []; particles = []; lasers = [];
            typed = ''; targetedEnemy = null; lastSpawn = 0;
            startTime = null; wordsDestroyed = 0; totalCorrectChars = 0; errorCount = 0;
            // regenerate stars to fit canvas
            generateStars(100);
        }

        function drawPaused() {
            ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,canvas.width,canvas.height);

            // Pause title with glow effect
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
            ctx.font = '50px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', canvas.width/2, canvas.height/2 - 80);
            ctx.shadowBlur = 0;

            // Draw pause menu buttons
            pauseButtons = [];
            const resumeRect = drawButton("Resume Game", canvas.width/2, canvas.height/2, "RESUME", false);
            const menuRect = drawButton("Return to Menu", canvas.width/2, canvas.height/2 + 60, "MENU", false);
            const closeRect = drawButton("Close Game", canvas.width/2, canvas.height/2 + 120, "CLOSE", false);
            pauseButtons = [resumeRect, menuRect, closeRect];

            // highlight hover
            if (mousePos) {
                for (let i = 0; i < pauseButtons.length; i++) {
                    const b = pauseButtons[i];
                    const hovered = mousePos.x > b.x && mousePos.x < b.x + b.width && mousePos.y > b.y && mousePos.y < b.y + b.height;
                    if (hovered) drawButton(i === 0 ? "Resume Game" : i === 1 ? "Return to Menu" : "Close Game", canvas.width/2, canvas.height/2 + i*60, b.mode, true);
                }
            }
        }

        function drawGameOver() {
            drawStars();
            ctx.fillStyle = '#fff'; ctx.font = '50px Arial'; ctx.textAlign = 'center';
            ctx.fillText('Game Over', canvas.width/2, canvas.height/2-100);
            ctx.font = '30px Arial';
            ctx.fillText('Final Score: ' + score, canvas.width/2, canvas.height/2-30);
            let acc = 0, wpm = 0;
            if (startTime) {
                const total = totalCorrectChars + errorCount;
                acc = total > 0 ? Math.round(totalCorrectChars / total * 100) : 0;
                const minutes = (Date.now()-startTime)/60000;
                wpm = minutes > 0 ? Math.round(wordsDestroyed/minutes) : 0;
            }
            ctx.fillText('Accuracy: ' + acc + '%', canvas.width/2, canvas.height/2+10);
            ctx.fillText('Words Per Minute: ' + wpm, canvas.width/2, canvas.height/2+50);

            gameoverButtons = [];
            const menuRect = drawButton("Return to Menu", canvas.width/2, canvas.height/2+120, "MENU", false);
            const closeRect = drawButton("Close Game", canvas.width/2, canvas.height/2+180, "CLOSE", false);
            gameoverButtons = [menuRect, closeRect];

            if (mousePos) {
                for (let i = 0; i < gameoverButtons.length; i++) {
                    const b = gameoverButtons[i];
                    const hovered = mousePos.x > b.x && mousePos.x < b.x + b.width && mousePos.y > b.y && mousePos.y < b.y + b.height;
                    if (hovered) drawButton(i === 0 ? "Return to Menu" : "Close Game", canvas.width/2, canvas.height/2+120 + i*60, b.mode, true);
                }
            }
        }

        function gameLoop(ts) {
            if (!running) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }
            ctx.clearRect(0,0,canvas.width,canvas.height);
            drawStars();
            if (state === STATES.PLAYING) {
                const cfg = DIFFICULTIES[difficulty];
                if (!lastSpawn) lastSpawn = ts;
                if (ts - lastSpawn > cfg.spawnRate) { spawnEnemy(); lastSpawn = ts; }
                // Update & draw enemies
                enemies.forEach(e => { e.update(); e.draw(); });
                // Update & draw particles
                particles = particles.filter(p => p.life > 0);
                particles.forEach(p => { p.update(); p.draw(); });
                // Update & draw lasers
                lasers = lasers.filter(l => l.life > 0);
                lasers.forEach(l => { l.update(); l.draw(); });
                drawPlayer();
                drawHUD();
            } else if (state === STATES.MENU) drawMenu();
            else if (state === STATES.PAUSED) { enemies.forEach(e=>e.draw()); drawPlayer(); drawHUD(); drawPaused(); }
            else if (state === STATES.GAMEOVER) drawGameOver();
            requestAnimationFrame(gameLoop);
        }
        requestAnimationFrame(gameLoop);

        // Touch support for menu clicks (mobile)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleClick(e);
        }, { passive: false });

        // If the player loses all health, show game over
        // Check health in loop as well (in case of external change)
        setInterval(() => {
            if (player.health <= 0 && state !== STATES.GAMEOVER) state = STATES.GAMEOVER;
        }, 200);

    </script>
</body>
</html>
